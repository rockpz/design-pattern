1: cnodejs社区的coordcn
https://cnodejs.org/user/coordcn

#1  异步感悟
痛点下面那张图太老了，libuv早独立了。

不管是promise，还是generator/yield，还是async/await都不能代表异步的未来，异步的未来是没有显式的异步，是形式同步。

现在nodejs的异步模型是受限于javascript历史和现实的妥协产物。

这个世界是异步的吗？这个世界是异步的。我们可以跟其他人或物协作，形成异步，但就我们个体而言，我们是同步的，因为我们只有一个大脑。当我们只有一个人的时候，我们能做的顶多是将事情排个优先级，先做什么后做什么，但事情还是得由自己一个个去做。异步的本质是借助外部资源与自己协同做事情。

这个世界是并行的吗？这个世界是并行的。我们可以将任务分发给其他人或物，并行执行，但就我们个体而言，我们是无法并行的，因为我们只有一个大脑。当我们只有一个人的时候，我们就无法并行。并行的本质是借助外部资源一起做事情。

一句话概括起来就是，这个世界是异步，是并行的，但我们每个人却不是，在没有外部资源配合的时候，我们只能顺序同步的一件件完成任务。当然这个结论对某些牛人而言是不正确，他们或许可以自己跟自己异步，自我并行。。。

我们需要跟其他人合作，我们需要团队资源，我们需要异步，需要并行。但请注意，我们真正需要的不是异步和并行本身，而是由他们带来的好处，带来的效率上的提升。异步和并行是需要代价的，跟其他人合作，就要有沟通，如果团队沟通出现了问题，团队效率可能会不及个人。沟通方式是非常重要的，可以通过消息提醒，可以通过回调。消息提醒是人类常用的，我们要分一定的神去关注别人的消息，还要过滤垃圾消息，提取有用的，这个模式对小规模的业务是有效的，每个人专注一两件事情。回调则是按照我们规划好的，一层层响应关系事先注册好了，来了订单，形成了生产命令，经理注册的审批回调就触发了，经理审批完成，财务注册的财务审核的回调又触发了，财务审核通过，采购注册的采购回调，车间注册的生产回调触发了，开始备料，采购到货，品管注册的来料检验回调触发了，如此一层层的回调自动的触发下去，直至最终货到客户手中。回调由于是事先规划好了信息传递他规则，不需要一层层的检索信息，再进行转发，每个注册回调的人员都能及时的做自己该做的事情。从这个意义上来说，回调模式下的流程管理比消息转发模式高效得多。

这个例子其实不是要告诉大家回调好厉害，好伟大，这个大家都清楚。这个例子是要告诉大家，回调的本质，回调就是来保证执行顺序的，是保证流程的，这个过程中不管是异步，并行，都被层层注册的回调控制得死死的，先做什么后做什么，事先已经规划好，订单来了，经理不批，后面的流程就走不下去。讲到这里，聪明的人已经理解了我的用意，千万不要以为回调就是异步，回调跟异步半毛钱的关系都没有（同步代码，只要你愿意，同样可以用回调来表达），回调这个模式只是碰巧（相对效率高）能够准确的表达异步，能够有效的约束异步关系，形成准确的执行链条。回调保证的其实是同步，是顺序，是业务逻辑上的同步和顺序执行。

世界是异步的，世界是并行的，特么业务逻辑竟然是同步的，是顺序执行的。这就是nodejs异步痛苦的根源，这也是很多人不愿意承认的矛盾。这个矛盾也恰恰是promise，generator/yield，async/await出现的原因，但他们都不完美，他们或多或少的都要兼容过去的回调代码，这是语言的历史和现实造成的，估计短时间改变的可能性不大。

如何实现形式同步，如何隐藏回调，大家都在探索，fibjs，openresty，很多项目都在做，转换和隐藏回调的钥匙在协程。

总之，请记住，你所要写的业务代码逻辑上总是同步的顺序的，nodejs痛苦的根源就是用显式的异步代码去表达同步顺序的业务逻辑，你的内心，其实希望写同步代码。

#2  会的层次
我不搞nodejs，随便讲讲我的一些想法。

同样是个会字，不同人有不同的理解，不同的公司会有不同的需求。

有的人知道个名词就敢说自己会了；
有的人扫了一眼文档就说自己会了；
有的人用这个技术做了个项目就认为自己会了；
有的人用这个技术做了好几个项目，踩了好几个坑，并且把这些坑都填了认为自己会了；
有的人边用，边踩坑，边看源代码，把整个技术原理搞清楚了，可以做一些修改和改进，他认为自己会了；
有的人搞懂了原理，自己实现了一个自娱自乐的复制品，他才认为自己会了；
有的人在技术原理的基础上做了一些改进，并实现了一个与原技术竞争的产品，他认为自己会了；
有的人在搞懂别人的技术原理之后，另辟蹊径，实现了一个与原技术完全不同的产品，这也是叫会了；
我个人认为，1，2阶段除非大牛，其他人说会大多是吹牛；3属于入门阶段，照着文档做一个项目是最基本的要求，做出来的东西属于玩具，这样的人可以招来培养；4属于熟练，可以做产品，这是公司的主力；5，6属于精通，大部分公司的技术团队领导都属于这个水平，小牛；7，8则属于超越，大牛，凤毛麟角，大公司的某个方向上的技术负责人；

按照这个标准，大部分人其实都属于3，4的程度，这个论坛上5，6不多，7以上的就更少了。国内搞node的能够为社区贡献源代码的不多，贡献的也都是一些非核心的代码，js代码居多，c和cpp代码的少。静下心了跟过源代码的很少，5层以上大多是应用级的大牛。前两年有一批水平1，2，3层的来论坛群嘲，现在基本已经没有了，但论坛也没以前活越了。说明社区越来越成熟了，node越来越成熟了。

对普通开发者而言，水平3，4层就算基本合格了，努力点朝5层加加油，深度广度扩展扩展，前后端，数据库都搞一搞，部署，运维都涉猎下，努力做个5+吧，我自己的技术路线大概也就是5+的水平。

#3  Node也许不是构建大型服务的最佳选择
Ryan提及的“大型服务系统”是 《DNS服务器集群》类的 底层基础设施。这个领域一般都是Cpp的主场。类似于我单位里的LBS服务组件，Go都不一定是最佳匹配的工程技术，因为Go是GC语言 且 有垃圾回收延时 — 因此，我不认为Go或JAVA比较js高级多少，他们无非是50步笑100步。此外，如果不考虑Cpp的开发者比较多、容易招聘的话，我认为Rust才是 最佳 与 最折中的 工程技术选择（内存安全 与 开发效率，还不需要那么多的老司机）。
所以，我认为Ryan的观点 与 Node.js在后端“胶水语言”的使用场景并不冲突。即，这两者就不在同一个维度上：
Ryan说的是 被“胶水语言”包装的核心引擎。难道JAVA与PHP就适合做这一部分的业务了？
Node.js是包裹核心的“胶水”。除了与html5技术不兼容之外（潜在增加了人力成本与学习成本），JAVA与PHP相对于Node.js又有什么独一无二的技术优势？

赞同你的观点，我之所以没有把文章的标题也复制过来，就是不想引起骂战，而是希望读过文章之后引起有心人的思考。
合适的场景用合适的技术这个技术选型的根本点很重要，后端真的不是哪一门语言能一统天下的。
有些人对我转这样的文章有意见，甚至有的人恶语相加。你们可以这么想，我不发，别人就不会发？我不发，别人在其他地方就看不到？那个引战的标题我特意没有转过来，这个标题是翻译的人后加的。
对这篇文章反应越大的，越激动的，可能是承受能力越不行的。对真正技术好的，不管是做node的还是不做node的朋友，一篇文章仅仅是一个看问题的角度而已。而且Ryan已经离开node的，他就是个了解内情的局外人。他说的对，听一听，不对的，他一句话能灭了node？况且人家的观点和现实情况是吻合的，node主战场还是前端工具链和初创项目，node也的确不适合做底层，node的编程模型相对于其他语言的确落后了，性能也不再有优势。
真正了解node的人，必然是对node优缺点都了如指掌的人，也是能够客观看待并接受node优缺点的人。
这个道理就如你喜欢某个女神，当你没有跟她深入接触的时候，你觉得这个女神是完美的，但当你跟她深入接触后会发现，女神也有缺点，也要吃饭拉屎，如果你发现了这些缺点并包容了这些缺点，你才真正准备好和女神结婚了，否则就有可能像李敖因为胡因梦便秘而和她离婚。

不是大牛，但可以给你点建议。
如果你有志于前端，node必学，因为现在前端的构建工具链基本都是node的搞的。
如果你有志于后端，则不仅仅要学node，其他框架，语言，数据库等都要学。
如果你想做一个项目原型，你对node比较熟悉，前后端都会，node是性价比比较高的选择。

在我看来，计算机语言主要就分“GC语言”与“非GC语言”。在同为GC类语言的前提下，各种技术虽然各有偏重，但是，并不存在数量级的差距。
从历史上看，非GC语言一直都很清爽。主要也就包括这么几个计算机语言：C, Cpp 与 新秀的Rust。
但是，另一方面，非GC语言 又分为
虚拟机预安装语言（比如，JAVA需要JVM, JavaScript需要浏览器或Node.js）
虚拟机与App程序共同打包在一起的语言。最典型的就是Go。Go不需要预安装虚拟机。但是，你是否曾经怀疑过：Go没有预装的虚拟机，那么谁给它做内存管理？答案是：Go的虚拟机与App程序打包在一起了。但是，Go的虚拟机很小（相对于JVM而言），而且Go只做Server端的程序，程序安装包的尺寸并不是主要的 性能考量指标。所以，这个问题并不致命。

要想知道问题的答案，最好的方式就是自己去求解，别人的只能作为参考。
以下是我个人的理解：
从最初的callback，promise，generator/yeild，一直到async/await，异步程序编写方式越来越向同步靠拢。所以我评判语言异步模型先进与否主要是看和同步代码的相似度，最好的异步是没有一异步。所以async/await相对于完全同步的代码模型上肯定是落后了。但我并不赞同go的模型更先进的说法。
回调的问题大家现在已经形成共识了，这个基于回调的异步模型，代码编写还是小事，后期维护那才是大事。基于回调的异步不是什么新鲜的东西，C语言通过函数指针实现，nodejs的异步库libuv就是用C语言实现的，有兴趣的大家可以去阅读相关源代码。
很多人对回调有一个误解，认为回调就是异步，其实回调只是异步的一种实现方式，回调是来保证同步的，保证我们业务代码的逻辑顺序的。 如果你不需要保证逻辑顺序，比如你开一个线程写入文件，你并不需要知道写入成功与否，你是不需要注册一个回调函数去接受这个线程的执行结果的。
这个就引出了一个问题，回调异步这种形式异步恰恰是为了保证同步，这就是编程模型和业务逻辑之间的冲突，ES这些年为了解决这个问题，引入了promise，引入了生成器，引人了async，其根本原因就是想解放程序员，我们必须承认，这些模型的引入相对于js这门语言而言是有进步意义的。但如果跟其他语言相比较，js已经落后了，当别的语言已经做到用同步代码写异步程序的时候，js还在醉心于async/await这种显式的异步语法糖，而且大家都认为这是一种理所当然的状态，那就有很大的问题了。
解决这个问题的钥匙在协程，erlang，lua，go，php（非官方）等语言都实现了stackful的协程，协程相对于线程而言，切换消耗小，可以将显式的异步代码转换为形式同步，实质异步的代码，也就是用同步模式写异步程序。我的主语言是C和lua，go略懂，我们以lua为例：
local fs = require("fs")
local ret, data = fs.readFile("text.txt")
print(ret, data)
这是我个人项目luaio里的一个例子，代码没有异步的影子，但read却是异步执行的，奥妙就是在协程，这段代码其实是被一个协程包裹着，当发起异步调用时，开启线程读文件，在C语言层面，我们主动让出当前协程的执行权，当读取线程完成后，把结果压入协程堆栈，唤醒协程继续执行。通过语言赋予的机制，我们很好的隐藏的异步实现。这种隐藏付出的代价就是协程切换的代价，跟回调比肯定是有损耗，但跟生成器之类的模拟协程比并不差，而且隐藏的更彻底。哪一种更先进大家肯定自己有自己判断。

协程模式也能实现并发或并行，不管是lua还是go都是开启多个协程，多个协程之间是并发或并行执行的，协程内部则是顺序执行，保证业务逻辑的。具体代码就不贴了，大家有兴趣的可以自行研究。
下面是js版本：
var fs = require("fs")
function readFile(name) {
    return new Promise((resolve, reject) => {
        fs.readFile(name, "utf-8", (err, data) => {
            if (err) {
                reject(err)
            } else {
                resolve(data)
            }
        })
    })
}

async function read() {
    var data = await readFile("t.txt")
    return data
}

read().then(v => console.log(v))
promise化的代码我手写的，大家正常都用包装函数，所以手写那部分代码可以忽略。我们主要关注，在这个过程中，async/await传递是什么？传递的是promise，跟lua代码比起来，这里不但出现了显式的异步关键词，更要命的是，这里异步传递的不是值本身，而是值的包装，我们要获得里面的值，还是需要用回调来拿，也就是说，async/await只能保证一定范围的同步，而且这种同步是基于promise的，值的传递依赖于promise。当然很多朋友已经适应了这种模式，毕竟他们从callback，promise，generator/yeild一路过来的，这些都不是事，但对其他人未必是这样。如果我直接写同步代码，又获得了异步执行的好处，我为什么不写纯粹的同步代码呢？借助协程，根本不需要任何包装，也不需要任何适应，甚至脑子里不需要有异步的概念，我就写出了异步程序。

选择语言看你自己的需求，还有就是自己喜欢，用着顺手舒服。
生产力这个东西因人而异的，跟语言的生态，自己对语言的熟悉程度，自己填坑的能力都是相关的。
按照应用层次不同我列出几个作为参考
C，rust
go，java，erlang
javascript，php，python，lua
系统级C语言肯定是当之无愧的王者，但现在竞争者rust，go都是虎视眈眈的，完全取代不现实，但部分替代已经做到了。C语言语法简单，代码编写一定源码阅读量之后也不难，C语言难的是调试，一个段错误重现，捕捉，定位耗费十天半个月太正常了。我个人的选择是C语言。
应用级或者中间件，我个人认为java，go，erlang都是不错的选择，rust也可以考虑。我个人的选择是go。
接口级nodejs，python，php，lua都可以，他们都有相应的高性能实现版本，php的swoole，lua的openresty。我个人的选择是lua。

用async/await关键词隐式注释业务逻辑这个做法本身就值得讨论，我个人认为直接在业务逻辑代码旁边写明为什么这么做比两个关键词要让人容易理解得多。你可以做个试验，让别人来理解你的代码，是不带关键词但有注释容易理解，还是带关键词不带注释容易理解。用这个来说明先进性恐怕说服力很不到位。
async/await只能保证函数内部的形式同步，函数执行后取值还是需要通过then来取得，这跟完全形式同步比，说是更先进恐怕也不合适，真正的形式同步任何时候返回的都是自己想要的值，根本不需要去关注promise，promise从某种意义上来说是传递的媒介，所有异步操作都必须被包装成promise才能运作，最后也必须通过promise取的最终的值，真正的形式同步是不应该有这种负担的。
对于从callback，promise，generator/yield一路过来的人，这些都不是问题，async/await的确是巨大的进步，但跟其他语言相比，离形式同步看起来也不差很多了，但实际上还差很远。如果要引入真正的stakful的协程，前端体系要推倒重来，而javascript不可能为了nodejs来改变，node只有被动的接受，被javascirpt标准推着走。
我说node的缺点，不代表我鼓吹其他语言，反对node。我认为node作为前端构建工具链，为前端工程化作出了巨大的贡献，我认为能够hold住前后端的同学，尤其有深厚前端功底的，选择node是正确的，选择跟你的项目大小无关，跟你的能力有关。
有的人还认为node是编程模型最先进的，生态最好的，甚至还认为性能也是最好的，那我有责任出来说一些实话，会让一些人不舒服，但后端真不是一门语言能够扛得起来的，选择node，有志于后端的，必须要关注其他后端语言。

非GC类语言。我选择Rust，原因是WASM与高性能后端服务组件。（打点，要求性能）
GC类语言。我选择ECMAScript，原因是广泛的跨平台适应性。（打面，要求跨平台成本低）
最终是：点面结合。GC类语言真心是太多了。但是，我精力有限，所以选择一款平台适应性比较强的GC语言。

选择语言跟你的需求相关，跟自己对语言的熟悉程度相关，跟自己的填坑能力相关。
C++是主流，培养一个能填坑的程序员要花多长时间？这门语言恐怕是从入门到放弃人数最多的语言。
java是主流，但对我而言，go上手更快。
javascript在前端是绝对的主流，但后端可选择的语言太多了，javascript在后端也是主流么？
其实选语言是很个人的问题，语言的优劣深入使用后才知道。 我对C，go，lua都不满意，很多坑得自己填上。lua后端缺这库，缺那库，没关系，只要C语言有的，lua就有了。实在不行，看看其他语言有没有解决方案，rpc，http丢给其他语言。

node在后端肯定是有一席之地的，现在node本身和社区都成熟了，刚火的时候秒这语言那框架的，现在用的顺手的默默的用，不想用的肯定也不会用。
后端语言性能现在差距不大，拼的就是生态，编程模型，上手难度，开发效率。
node最大的贡献在前端工程化，这个怎么赞美都不为过。但后端要node来扛肯定不现实，毕竟竞争语言太多了。而且前端自己也竞争做后端的人才，很多公司招聘也都偏向于前端。
我认为，有志于前端必学node，有志于后端node是可选的。如果选node后端的话，必须要有一定的前端基础。
node就是前后端的桥梁，可以偏向某一端，但知识体系必须联系起来才能创造价值。

同意“很多公司招聘也都偏向于前端”。我认为：
后端的（商业）业务很容易形成“赢者通吃”的寡头垄断。试问：全国能有几十家企业有机会做 像 阿里 与 腾讯 那样的 “大数据分析”，而且，还能 时不时地 发布一些颇有社会价值的 大数据分析结果？
如果因为寡头垄断造成这类公司很少的话，自然地 偏重后端的 就业市场的 规模 就会很有限。
另外，几乎我所知道的公司 都 重点研发 各种设备上的“大数据报表”。其中，甚至还有一些公司打着“大数据分析”的幌子，其实招的“大数据报表”的人才。
不同于“大数据分析”运行在后端专用业务服务器的Hadoop程序上，大报表主要是，通过Rest API获取大数据分析结果（可能会有少量的二次加工）。然后，技术重点就是Canvas 2D，WebGL（例如，好像有一款《3D机房管理》的产品），和移动平台适配了。

后端技术市场的《碎片化》已经不可逆转了。在可预知的将来，应该会出现更多的计算机语言参与到这个（狭窄）领域的 激烈竞争中来。之前的新参与者有Swift, Kotlin与ECMAScript，还有Rust。后面还会有哪些语言会出现，谁又知道呢？在后端领域，开发者的选择只能会越来越多，越来越丰富，因为《碎片化》不可逆。
至于，Node.js在后端业务中的立足点，在不考虑WASM支持的条件下，是做“胶水语言”。类似于，Ruby, Python, PHP，等等。
对数据库读写与查询：索引管理在DB里，不在JS程序里。
基于Redis做一些会话管理：Session ID的匹配与筛选，在纯C的Redis里。
调用FFmeg做一些视频与音频的转码。
至于“这些年，Node.js在后端应用场景的讨论”，或许是 开发者对Node.js期望比较高，还想让她担当除了“胶水”之外的角色。而，这类角色因为计算密度太高，一般都不适合于GC类语言来完成（不只是JS）。但是，因为WASM的支持，可能以后Node.js也能够覆盖这些领域吧。

#4  node.js后端需求
楼主你这么理解，很多人选择nodejs就是看中前后端语言统一，但矛盾的是， 这种前后端都懂的大牛，一般都是企业的中坚，他们不会轻易跳槽。而一些整天嚷嚷前后端通吃的，全栈的，很多其实是水货，所谓全栈，大部分是前端不强，后端略懂。 排除了真正的全栈大牛，前端大牛如果前端干得很好，他们为什么还要主动多干一份后端的活呢？前端的待遇可不比后端差。
其实把nodejs定位成前端工具比较好，各种前端基础设施让前端自己去开发。创业项目中小规模的也可以，但这样的项目大多是有一个全栈牛人带的。你们团队如果没有这样的牛人，我认为趁早放弃nodejs，选择合适自己的语言生态。如果有这样的牛人，不妨招聘一些有一定js基础，有志后端的同学，自己培养。

#5  node.js面试
作为一名多年的面试官，从我的经验来看，几乎不看学历。
工作经验两说，不是一定要长，关键是看你的工作年限和你的经验值是否匹配。
至于框架什么的，看你是「用过」是哪一个「用过」了。
你参与面试的时候，面试官希望听到你说 「我用过 xx 框架」，还是希望听到你说：「我在做 XX 项目的时候，预研过 XX 和 YY 框架，最终因为 XX 等原因，我选择了 XX 框架。在这过程中，我遇到了 XX 问题，为此我去看了 XX 源码，发现他们是基于 XX 原理的，还有优化的空间，于是自己尝试了 XX，解决后写了 XX 总结文章，甚至尝试给 XX 框架提了一个 PR 解决了这个问题」。
见过很多一年工作经验用十年的所谓的十年工作经验程序猿。

https://www.zhihu.com/lives/812367829423779840
https://zhuanlan.zhihu.com/p/27235590

规范性：包括文档，代码风格，代码质量，单元测试等等。
如果仅仅是写一段没啥代码提交上去，等着面试官挖掘，不好意思没用，反而扣分。（我就遇到一些，简历上提供了一个代码仓库，点过去，没 README，没注释，一眼看不出代码是干嘛的，后面才知道，他是想表达自己会函数式编程。然而，我看不到任何有意义的内容，反而觉得他在对我说：快去看啊，代码里面有呢，你懂不懂啊？看不看得出来啊？）这种你还不如写一篇博客文章。

每个人的评价角度不一样吧，从我的角度，简单看了下，有以下可以提升的空间：
命名混乱
没有 eslint
虽然有 test 目录，但没有单元测试，没有覆盖率
文档一般，对排版不注意
git commit message 不太注重，提交比较随意，对分支协作不了解。

个人也更倾向于王垠的观点，现实的理想主义者。
代码写得漂亮，文档漂亮和代码有价值是两码事情。
代码测试覆盖率很漂亮和代码没有bug也是两码事，测试只能保证代码没有明显的错误，并不能保证没有错误。
最好的协作是不协作，现代社会不分工协作不现实，但我们可以通过把分工做细一点，每个人之间工作交集尽可能的少，这样就可以避免一些不必要的冲突，责任也可以明确。微服务和模块化这么流行就是这个道理，尽量少的团队和人去实现一个微服务或模块，保持接口稳定，其他人通过稳定的接口来调用服务和模块，这是典型的通过分工解耦的过程。nodejs成功的关键是npm，如果没有好的模块管理系统，就很难形成好的生态，这些生态就是由许许多多小而美的模块组成的。
我不会拘泥于某种流程，适合自己和团队才是好的，代码规范也是同样的道理，有一个基础的规范大家形成共识和遵守就行了。

技术基础
操作系统
    磁盘文件相关基础，文件描述符，文件打开选项等
    进程,线程基本概念，进程创建销毁通讯等，线程创建同步等
    基本的同步原语，信号量，条件变量，锁等
    Socket 基础接口
数据结构/算法/设计模式
    线性表(数组，链表)，Hash表，树
    排序，遍历，查找等
    观察者，生产者消费，单例等
网络基础(TCP,HTTP等)
    TCP/UDP 概念与区别，典型运用场景
    HTTP 报文介绍，常用状态码
    CDN 等网络代理的工作原理
Node.js 基础
    详述 Node.js 并发原理(libuv工作机制)
    核心 API 的实现架构(如何 binding 到 V8)
前端相关(AMD,路由,单向数据流,双向绑定原理)
    前端模块化原理，如何实现一个模块加载器
    如何实现一个前端路由？
    如何自己实现一个双向绑定组件？
App相关(jsbridge, Weex/React Native 原理)
    Hybrid App下，如何实现 jsbridge
    类似 Weex/React Native 方案的原理，以及如何实现上层 DSL？
编程语言(JS/Java/C++)
    OOP (其他实在不知道问啥)
项目开发
    研发流程: 完整的研发流程是怎样的？需求，编码到发布和运维。
    运维管理: 运维体系是如何做的？有实践过 DevOps 吗？
    项目管理: 项目开发运用何种管理方式？有实践过 Agile / Scrum 吗？
拓展思考
    当前所做项目，流量扩大10倍，该如何应对？
    如何提升手头项目的研发效率？
    如果，你合作的同事数量扩大10倍，该如何提升协作效率？
开源社区
    你参与开源社区吗？
    你有发起过开源项目吗？
    参与了什么项目？
    运作流程是怎样的？

但尼玛根本就不可能，正常情况是随机找N个点，追杀，追杀，再追杀，基本问到底层实现。
要以这个方向覆盖整个知识点，除非你的实力远远超出面试官。
建议你还是找几个难的地方专攻，其它原理大致了解，面试官一深问，老实回答不知道。一可以展示知识面，二表示诚实，三等到面试官深问你专攻的地方的时候，把面试官秒了，教他做人，告诉他一些很细他很难知道的东西。
形成晕轮效应，这个时候面试官才会觉得你牛逼，真要把全部做为方向就完了

#6 openresty在Shopify中的应用
http://www.infoq.com/cn/news/2017/11/shopify-commerce
Rule banner: 通过查看不规则刷新、可疑IP地址等异常模式发现僵尸程序，进而禁止这些异常模式。该模块的目的是关闭二级市场。
Edge cache: 对缓存做优化，允许在负载均衡层而非应用层的缓存提供内容。
Checkout throttle: 节流限制通过对一些商户进行排队，实现对这些商户在异常负载下的写入操作，从而防止一家商户变成同一片上其余商户的嘈杂邻居。

#7 大型web需要思考的点
单机QPS多少？
需要多少机器来应对峰值流量？
需要冗余多少机器？
机器之间如何共享状态？
如何做负载均衡？
在网络模型的第几层做负载均衡？
做多少层的负载均衡？
负载均衡请求失败后如何处理？

#8
成功的人在某个领域获得成功后，可通过经营杠杆进入任何他们想要涉足的领域。而这都得依赖于曾极致地专注于做好一件事情。

＃9 编程的智慧
反复推敲代码
优雅的代码具备盒子特征和树状特征
写模块化的代码
避免写太长的函数
制造小的工具函数
每个函数只做一件简单的事情
避免使用全局变量和类成员来传递信息
写可读的代码
使用有意义的函数和变量名字
局部变量应该尽量接近使用它的地方
局部变量名字应该简短
不要重用局部变量
把复杂的表达式提取出来，做成中间变量
在合理的地方换行
写简单的代码
避免使用自增减表达式
永远不要省略花括号
不要盲目依赖操作符优先级，合理使用括号
避免使用continue和break
写直观的代码
写无懈可击的代码
正确处理错误
正确处理null指针
尽量不要产生null指针
不要把null放进容器数据结构(Map, Array, List, Set)里
防止过度工程


#10 在做程序员的道路上，你掌握了什么概念或技术使你感觉自我提升突飞猛进
1书2概念
1本书: Designing Data-Intensive Applications, 对应程序员3能力中的工具箱深度广度
两个概念-1: 多范式编程和最小表达力原则(least expressiveness principle), 对应程序员3能力中的程序语言理解深度和表达抽象能力
两个概念-2: 领域驱动设计(Domain Drive Design), 对应程序员3能力中的方法论，编程大道(programming in the big)和架构能力
1. 工具箱广度深度，或者说在技术选型上控制系统复杂度的能力，广度：懂多少数据库／数据处理框架／AWS几个重要的Service了解多少／著名的开源软件框架工具了解程度。阿莱克西斯：后端所谓复杂的问题是什么？ ） 广度决定了眼界； 深度：为什么数据库要这么实现设计，为什么AWS这个地方有这个缺陷（比如SQS为什么是可乱序的queue），看似类似的几个框架，在本质上有什么不同，是在哪个本质问题上做了哪些决定行的trade-off导致了它们在设计实现和提供的功能上分道扬镳？ 深度决定了能否真的在合适的场景应用合适的能力与工具。
2. 程序语言理解深度和表达抽象能力，这是在实现上控制复杂度的能力，懂不懂得最小表达力原则？懂得几种编程范式？它们之间怎么根据具体情况作出取舍？是否知道怎样才能把code写成诗？怎样才能在重重困难中，坚守高聚合、低耦合？怎样组织程序，才能使得让程序正向流动产生期待效果之外，程序能否根据效果／结果，倒推并很容易的倒推出这样的一种结果是由什么原因，那个组件造成的(这是系统怎么才能很容易进化的关键，也是“做出来就是好的”程序员最难克服的一点)？code写出来逻辑线是否清晰可见？阿莱克西斯：编程到底难在哪里？
3. 方法论，编程大道(programming in the big)，和构架能力，这是在时间跨度的整体上控制复杂度的能力，辨别什么是对的，应该做什么的能力；在时间跨度上，在信息不完整的情况下，现在怎么构架，才能使得当将来信息完整了，我们能很轻松的根据将来的正确信息，把系统调整成最好最正确的状态，什么决定应该现在做，什么决定可以和怎么样才能留给将来做，并且在这个过程中，保证能够支持业务正常运转。在整体上，怎么把需求获取/设计/coding/测试/安全/部署/运行监测/报警/性能/系统回馈分析/数据统计/报表…等等在全局把握，安排的妥妥当当相互支持而不是相互抵触，相互使绊子。这里包含的知识包括，到底是waterfall， TDD，BDD，还是type driven，怎么执行Agile，什么是devOps，continuous delivery。 到底应该是技术决定业务，还是业务决定技术？。给一个100人的团队和超复杂／抽象的需求（比如需求就是让公司业务翻一倍，怎么翻一倍这个抽象问题要怎么分解成n个大问题，这n个大问题怎么分解成m个中问题。。。。），怎么把抽象问题落到实处，怎么能把大的问题分解成哪怕是比较弱的程序员也可以解决的小问题，然后还要证明这是根据现在的信息，可以做出的最好的决定。2017年，你看了啥很好的计算机的博客/书/视频？  这个回答中关于DDD和Clean Architecture的介绍讨论了一些这方面的问题您可以看下。
关于一书：Designing Data-Intensive Applications： 由于我的主要工作是利用云技术，做后端的大数据模型，或者高性能，高弹性，高可用性的service，所以数据处理，和云技术是我工具箱里最重要的一部分工具。我之前比较深入的（内部怎么工作的深度，每个系统至少读过一本书，有一些看过源代码）学过Oracle, HBase, Cassandra, Redshift, Hadoop, Spark Kafka, Storm, Zookeeper...Amazon自己的DynamoDB, Kinesis, SQS／SNS, AWS Lambda, Step Function, SimpleWorkflow, EMR... 但是我的学习是像没头苍蝇一样的，是盲目的，哪个技术火，就学哪个，总觉得这些东西之间模模糊糊的是有联系的，感觉是有一些东西是可以总结起来的。。。脑子里或者说工具箱里里的东西很多，但是却非常乱，概念实现经常记混，我经常在想：如果能总结归类，用更科学的方法去记住所有我学过的技术，那就好了。。。然后我就遇到了这本书，我读了三遍，然后感觉一切都理顺了… 如果我先读了这本书，才去学上边这些东西，那么我花费的时间将是原来的3分之一到5分之一左右。这本书在广度和一定程度的深度（如果对进一步深度有要求，可以读完此书的reference）上，概括和总结了数据系统，分布式或非分布式环境下面临的本质问题，和解决方案的分类，看完这本，我开始理解了“为什么”这么多的分布式系统要这么设计。而这本书上千的引用论文，给我指明了一条系统学习理论的明路。
关于多范式编程和最小表达力原则(least expressiveness principle)：学了好多语言，设计模式，AOP，范型，反射，DCI。。。不知什么时候起，我已经忘记了我为什么要学习他们了，我的程序开始变成一个程序员的行为艺术，简直可谓花式编程。怎么样能用别人都不懂的花式技术秀翻全组，变成了我觉得可以体现我的学识的关键。。。（在这里要跟接手和维护我花式行为艺术的同学深深的道歉。。。）直到我了解到了多范式编程(Multi-Paradigm Programming)和最小表达力原则(least expressiveness principle), 我才中混沌中惊醒，回归初心，简化程序，用尽可能简单的程序来解决尽可能复杂的问题，才是我们发明和学习了这么多技术的最终目的啊！
关于领域驱动设计(Domain Driven Design)：从具体的大处来说，它让我明白了“为什么要有程序员”，这个话题很大很抽象，下边的引用有一些详述。 从小的来说，它让我懂得了怎么样用系统的方法来设计系统，实现系统，从而让VP，Director，各级开发经理, 产品经理，客户，和我们组配合的机器学习科学家，统计学家，经济学家，他们脑子里的系统，和我们程序员的code的组织，系统的组件设计实现是有清晰的对应。一个小的脑子里的模型改动，必然只会引起一个系统的小的改动。这，是在长远的时间角度，在考虑了未知的未来，考虑了明天的你，团队，客户，都会收到新的未知的信息的情况下(而不是根据一个时间点的需求)保持一个健康，可业务拓展，有竞争力的，能够成为组部门公司之脊梁的系统的关键！用比喻义来说：如果说Designing Data-Intensive Applications是逍遥子百年功力，是莽牯朱蛤，是张无忌吃的昆仑山蟠桃，给你无穷的内力，那么这些方法论则是北冥神功，九阳神功，易筋经，教你如何驾驭这力量，而不是自爆而亡。
写代码原则：
kiss原则：keep it simple and stupid.

#11 后端所谓复杂的问题是什么？
碰巧答主是做 python 并且在一个用户量不小的公司。我就列下业务后端会碰到的一些问题吧：
1.复杂度控制，业务多了，代码量上去了，如何控制代码不失控，如何拆分业务实现微服务，如何快速响应需求(软件工程和业务领域本身的复杂性）。代码大全有一句话非常好『软件构建的核心就是控制复杂度』
2.存储模型。关系型、内存型、文档型、列式存储、地理位置存储等。数据量上去了就涉及到分布式存储，数据库、分布式这块就够你研究了。最近很多同事推荐了《Design Data Instensive Application》，这本书涉及到了很多存储模型和架构，围绕高可用、可维护性、可扩展性来讲的，推荐看看。Designing Data-Intensive Applications
3. 并发和性能优化。用户量增长到一定程度以后，原来的性能跟不上了(一开始为了快速开发使用了动态语言），怎么优化并发，提升性能是很重要的一块，甚至不惜换语言、数据库、框架、架构。需要了解各种语言和框架、负载均衡、消息队列、异步模型、缓存模型、并发模型等东西。
4. 系统设计。比如设计发号器、设计 feed 系统、设计缓存系统、设计推荐系统、登录系统、抢票系统等，在稍微上规模的公司你都可能会碰到，也是对有经验的工程师经常考的面试题。
5.大数据。这块和存储模型有点重合，数据量上去了就要上大数据比如 Hadoop 那一套，需要了解大数据存储这块。
另外，运维（devops 等）、架构、算法、数据分析等很多东西都能归到后端，目前的后端知识可以说是一个人短期内根本没法全面掌握的了，无论是想研究更深还是更广，一般我们是按照业务需求和自身兴趣有针对性学习。当然如果只是做个单机小应用，很多问题是碰不到的，大部分问题都是有了大量用户和数据以后业务增长才会面临的问题。

#12 读完《SICP》是一种怎样的体验
The Structure and Interpretation of Computer Programs
现在很多编程语言都是基于图灵可计算理论以及冯诺依曼体系结构模型设计出来，和图灵的可计算模型相等价的另一套模型则是阿隆索.邱奇的lambda演算。相较于图灵机lambda演算则要简单、优雅至极，下面是lambda 演算形式化表述：
<expr> ::= <identifier>
<expr> ::=(λ<identifier> .<expr>)
<expr> ::=(<expr> <expr>)
对“停机问题”的深刻理解，以及计算本质的理解，会让你倾向于相信：机器永远不会有智能。那些重复的机械的劳动最终必定会被机器取代，对于创造性的脑力工作者，比如程序员，机器将永远都取代不了。
阅读sicp有哪些困难？
时间。如果是在校生，至少也要花一学期的课余时间。如果是已工作了，有可能这辈子都读不完。
编程思维。99%的程序员平时使用的基本上都是命令式的编程语言，到函数式编程思维方式需要转变。
内容比较难，这是客观的事实。确实比较难。
sicp有什么缺点吗？有！它会让你在精神满足感之余，有一种孤独感。
https://github.com/jiacai2050/sicp

#13 爬虫
如果爬虫是涉及大规模网站爬取，效率、可扩展性、可维护性等是必须考虑的因素。
大规模爬虫爬取涉及诸多问题：多线程并发、I/O机制、分布式爬取、消息通讯、判重机制、任务调度等等，此时语言和所用框架的选取就具有极大的意义



不是所有的数据库操作都需要等待结果返回，再进行接下来的操作
封装成统一接口的话，接口参数会变得晦涩，不可取
memcahedAgent.query("cmd", )
流行的做法是一个命令对应一个方法
memcachedAgent.method(param1, param2, callback) {
    callback();    
}
continueDo();
分两种，一种是不关心返回结果，立即执行后面的逻辑
另一种是结果返回后再执行后面的逻辑，Promise async/await 解决了这类问题的回调地狱
如果把原生数据库交互接口Promise化,会不会影响到第一种情况的表达，比如更新数据库中两张表中的数据
yield A;
yield B;
如果是这种情况，使用回调代码会不会更简单清晰一点？

根据渠道来决定某个消息要如何处理
方法1 消息服务器端带上gameID,具体处理交给客户端
方法2 服务器端做过滤，此方法不可性。不清楚某个渠道下开放了哪几种游戏
方法1 是比较好的方案

#14 continuation passing style
https://blogs.msdn.microsoft.com/ericlippert/2010/10/21/continuation-passing-style-revisited-part-one/
https://blogs.msdn.microsoft.com/ericlippert/2010/10/22/continuation-passing-style-revisited-part-two-handwaving-about-control-flow/
https://blogs.msdn.microsoft.com/ericlippert/2010/10/25/continuation-passing-style-revisited-part-three-musings-about-coroutines/
https://blogs.msdn.microsoft.com/ericlippert/2010/10/26/continuation-passing-style-revisited-part-four-turning-yourself-inside-out/
https://blogs.msdn.microsoft.com/ericlippert/2010/10/27/continuation-passing-style-revisited-part-five-cps-and-asynchrony/

https://www.quora.com/What-is-continuation-passing-style-in-functional-programming
that's the core of CPS: functions take a callback argument and we bind their result to an argument of a function rather than a normal variable.

http://matt.might.net/articles/by-example-continuation-passing-style/

















































