http://www.freebuf.com/articles/network/128370.html

https://github.com/openresty/lua-resty-core/issues/55 


https://yjhjstz.gitbooks.io/deep-into-node/content/


http://luohaha.github.io/Chinese-uvbook/

//openresty 臭虫
https://www.openresty.com.cn/zz-translate-nginx-oom.html

//openresty manual
https://www.openresty.com.cn/lua-basic-manual-cn.html

消息队列
http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651745274&idx=1&sn=d839735113d06eb4368d42feeffa2239&scene=21#wechat_redirect

精读 Immutable 结构共享
https://zhuanlan.zhihu.com/p/27133830

麻将
https://github.com/zuoge85/majiang

javascript函数写法
https://zhuanlan.zhihu.com/p/27091503


Node Standard Library 是我们每天都在用的标准库，如Http, Buffer 模块。
Node Bindings 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务。
这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。
V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机。
Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力.
C-ares：提供了异步处理 DNS 相关的能力。
http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。

现在 JS 引擎的执行过程大致是：源代码 --->抽象语法树 --->字节码 --->JIT--->本地代码。
V8 更加直接的将抽象语法树通过 JIT 技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。 在 V8 生成本地代码后，也会通过 Profiler 采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化， 但极大减少了转换时间。

句柄   作用域   上下文环境

一个 Isolate 是一个独立的虚拟机。对应一个或多个线程。但同一时刻 只能被一个线程进入。所有的 Isolate 彼此之间是完全隔离的, 它们不能够有任何共享的资源。如果不显示创建 Isolate, 会自动创建一个默认的 Isolate。
后面提到的 Context、Scope、Handle 的概念都是一个 Isolate 内部的, 如下图： 

Scope
从概念上理解，作用域可以看成是一个句柄的容器，在一个作用域里面可以有很多很多个句柄（也就是说，一个 scope 里面可以包含很多很多个 v8 引擎相关的对象），句柄指向的对象是可以一个一个单独地释放的，但是很多时候（真正开始写业务代码的时候），一个一个地释放句柄过于 繁琐，取而代之的是，可以释放一个 scope，那么包含在这个 scope 中的所有 handle 就都会被统一释放掉了。
Scope 在 v8.h 中有这么几个：HandleScope，Context::Scope。
HandleScope 是用来管理 Handle 的，而 Context::Scope 仅仅用来管理 Context 对象。


全局对象与全局变量

global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量。
在最外层定义的变量
全局对象的属性
隐式定义的变量（未定义直接赋值的变量）
node.js中不可能在最外层定义变量，因为所有的用户代码都是属于当前模块的，而模块本身不是最外层上下文。node.js中也不提倡自定义全局变量。
Node提供以下几个全局对象，它们是所有模块都可以调用的。
global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。
process：该对象表示Node所处的当前进程，允许开发者与该进程互动。
console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。
Node还提供一些全局函数。
setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。
clearTimeout()：用于终止一个setTimeout方法新建的定时器。
setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。
clearInterval()：终止一个用setInterval方法新建的定时器。
require()：用于加载模块。
Buffer()：用于操作二进制数据。
Node提供两个全局变量，都以两个下划线开头。
_filename：指向当前运行的脚本文件名。
_dirname：指向当前运行的脚本所在的目录。 除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。

UDP vs TCP
TCP(Transmission Control Protocol)：传输控制协议
UDP(User Datagram Protocol)：用户数据报协议
主要在于连接性(Connectivity)、可靠性(Reliability)、有序性(Ordering)、有界性(Boundary)、拥塞控制(Congestion or Flow control)、传输速度(Speed)、量级(Heavy/Light weight)、头部大小(Header size)等差异。

主要差异：

TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；
TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3)Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。UDP发送数据前不需要建立连接。
TCP可靠，UDP不可靠；
TCP丢包会自动重传，UDP不会。
TCP有序，UDP无序；
消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。
从上图也能清晰的看出，TCP通信需要服务器端侦听listen、接收客户端连接请求accept，等待客户端connect建立连接后才能进行数据包的收发（recv/send）工作。而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发（recvfrom/sendto）工作。


所有的常用懒汉模式都已讨论完毕，仅推荐“双重检查锁定”（DCL）方式（符合思考逻辑）和“静态内部类”方式（任意 JDK 版本可用），它们共同的特点是：懒加载、线程安全、效率较高。
除了多线程、反序列化以外，反射也会对单例造成破坏。


producer consumer broker  每个组件细讲如何实现能够讲很多，比如producer如何保证消息高效发送，保证消息不丢。broker如何保证顺序队列，partition策略，消息是推还是consumer拉的？
如何保证消息一定会被消费。如何实现消息生命周期的可视化，便于排查问题。实现一个MQ遇到的问题比你想象放入多得多。
生产者消费者，交换，路由

select和epoll底层实现，在等待队列上等待的时候，是轮询的方式不断查看等待队列吗？还是操作系统异步callback直接唤醒的？
Fd挂的都是设备等待队列，当设备就绪后，就会内核内核唤醒等待队列的进程。这点三者没区别，区别是唤醒后select会用掩码来设置好fdset，虚啊哟上层来一个fd来检索。epoll是把fd直接挂在一个就绪队列。

epoll三个系统调用实际上就是维护内核的一个红黑树和单链表，新加入的事件放到红黑树，就绪的就从树中拿出来放链表，省去了拷贝和轮询操作。select理解为管理一堆文件描述符，每次都要把所有时间拷贝到内核，再轮询一遍。epoll采用的是回调函数。

原理其它答案讲得差不多了，我就补一句，从kernel层面将，事件产生有可能不是由硬件中断触发的，在一定情况下kernel的确会轮询，因为响应硬件中断是一个成本比较高的操作。以网卡为例，当数据量很少的时候，每来一个数据包网卡都回产生一个中断，kernel响应这个中断，从网卡缓冲区中读出数据放进协议栈处理，当满足一定条件时，kernel回调用户代码，这里的“回调”一般情况下是指从一个kernel syscall中返回(在此之前用户代码一直处于block状态)。当数据量很大时，每个包都产生一个中断就划不来了，此时kernel可以启动interrupt coalescing机制，让网卡做中断合并，也就是说来足够多的数据包或者等待一个timeout才会产生一个中断，kernel在响应中断时会把所有数据一起读出来处理，这样可以有效的降低中断次数。当数据量更大时，网卡缓冲区里几乎总是有未处理的数据，此时kernel干脆会禁掉网卡的中断，切换到轮询处理的模式，说白了就是跑一个忙循环不停地读网卡缓冲区里的数据，这样综合开销更低。


中断：
不是外界事件首先引发了中断跳转，跳转时顺便置上中断标志，而是外界事件导致置上了中断标志，然后中断标志再进一步引发了跳转。标志置上了并不等于立即就会引发跳转。标志本身只是用来看的，就是说，得等CPU看到这个标志，才能真正引发跳转。触发中断的，实质上既不是外部设备，也不是标志，而是CPU自己。CPU只在每个指令周期的开头瞅一眼中断标志，有，则进入处理过程，没有，则继续做它自己的事。如果不巧，标志置晚了，CPU已经瞅完了，那就只能等下一轮指令周期。所谓的屏蔽中断，就是人为在中断标志前面挂个幕布，不许瞅。只是不许瞅而已，但没有不许立标志，外部设备尽可以来立标志，只是立得再久也没人处理而已，直到幕布被摘下。当CPU瞅到了一个标志、并进入其处理过程之时，还会自己给自己戴个眼罩，此时哪怕还有别的标志，也瞅不见了，所以此时别的中断发生，也得不到处理。当CPU处理完了这个中断，会自己把眼罩摘掉，于是又能愉快的瞅标志了。如果有别的标志正巧竖在那，那就处理吧。显而易见，当CPU放眼一瞅的时候，瞅到不止一个中断标志是完全可能的，而它一次只能选一个来处理。一般来说肯定挑出其中最有价值的一个，剩下的先放着，等下回瞅。这就是传说中的中断优先级。再刨根问底一点，当CPU已经开始处理一个中断的时候，这标志会怎样？——根据中断的具体类型不同，这标志可能被CPU自动清除掉，也可能不会，而要等用户程序来手动清除。如果用户犯2了没清除标志怎么办？那么下次CPU放眼瞅的时候，这个标志还在！会不会再被处理一遍？——会的，而且不止一遍，只要你不清，它就根本停不下来。为什么系统要这么设计，给用户以犯2的机会？——有一种情况是，向量表不够装，多个中断共用一个向量，那么进入处理程序时，要有手段来区分到底是发生了哪个中断。所以标志要活到那个时候来给用户检查。然后我们终于面对了这个问题：如果一个标志还没被处理呢，就有人要来竖一个同样的标志（重点是：同样的），会怎样？——没错，前一个会丢失。竖标志的场地只有一个，只能记录标志有没有，不能记录标志有几个。——这不是很可怕？——别急，先来仔细分析下：很多中断，属于不作不死型：即，只有发起相应操作，才能收到相应结果的中断。不种瓜不可能得瓜。——对于这种，只要在收到前一个操作的结果中断之前不发起后一个操作（且不管机能上能不能做得到），就不会面临中断丢失的情况。还有一些中断，来几个意义都不变。比如我妈喊我吃饭，没等我去，我爸又来喊我一遍，最后我妹又来喊我一遍。无论如何，我最终都是去吃这一顿饭而已，不会吃三顿。这种中断自然也不怕丢失。若非以上情况，就没办法了，只能尽快处理，不要浪费太多时间在眼罩阶段，而耽误了瞅标志。然而……世事不尽如人意，如果长时间戴眼罩不可避免，又必须及时处理另一个中断，怎么办？有的系统具备一种功能，能让某些中断标志发出动感光波，射穿眼罩直达狗眼。妈妈再也不怕我瞅不着标志了，哪怕正在处理一个中断，也立即给你扔下，跑去处理另一个更NB的中断。这就是中断嵌套。自然不能所有中断标志都能发出动感光波，那世界就乱了。这种特权要严密控制，只能交给少量真正高大上的中断源。而当CPU进入这种中断的处理程序的时候，给自己戴的也不是一般的眼罩了，而是超强合金眼罩，连光波都能抵挡的，这保证了多个光波中断源之间也不会抢来抢去而乱了规矩。不过当然规矩也是人定的，没准某个系统里就需要有更更更高级的中断源，需要更更更强的光波，连合金眼罩也能射穿，同时自己还得具备更更更强的氪金眼罩……OK这是可行的，根据中断源不同，光波也好眼罩也好都存在多个级别，这叫做中断的嵌套优先级。而前面说的优先级则叫做中断的响应优先级。响应优先级和嵌套优先级是两个不同的概念，但有时被搞混。理论上，响应优先级再高也没法让你能打断别人的中断处理过程，嵌套优先级再高也没法让你比人优先被瞅到（当然先瞅到别人再被你打断另说）。当然，系统的关键中断往往两种优先级都很高。另外，多个中断的响应优先级一般没有同级的，因为事到临头总是要分个高下的。而嵌套优先级则可以同级，而同级一般是不能互相打断的。说回来，以上描述的参照的是答主自己熟悉的平台，别的平台可能有细微差别，但精神都是类似的。

http://blog.csdn.net/u013467442/article/details/51019691
微信朋友圈技术之道
业务快速迭代的压力和后台稳定性的要求：
极简设计
大系统小做
业务监控
KVSvr

系统自治对于无状态的接入层和逻辑层来说很简单，所有服务模块在海外数据中心部署一套就行了。
但是存储层就有很大麻烦了——我们需要确保国内数据中心和海外数据中心能独立运作，但不是两套隔离的系统各自部署，各玩各的，而是一套业务功能可以完全互通的系统。因此我们的任务是需要保证两个数据中心的数据一致性，另外Master-Master架构是个必选项，也即两个数据中心都需要可写。
Master-Master架构下数据的一致性是个很大的问题。两个数据中心之间是个高延时的网络，意味着在数据中心之间直接使用Paxos算法、或直接部署基于Quorum的KVSvr等看似一劳永逸的方案不适用。
最终我们选择了跟Yahoo!的PNUTS系统类似的解决方案，需要对用户集合进行切分，国内用户以国内上海数据中心为Master，所有数据写操作必须回到国内数据中心完成；海外用户以海外数据中心为Master，写操作只能在海外数据中心进行。从整体存储上看，这是一个Master-Master的架构，但细到一个具体用户的数据，则是Master-Slave模式，每条数据只能在用户归属的数据中心可写，再异步复制到其他数据中心。

数据中心间的数据一致性
这个Master-Master架构可以在不同数据中心间实现数据最终一致性。如何保证业务逻辑在这种数据弱一致性保证下不会出现问题？
这个问题可以被分解为2个子问题：
用户访问自己的数据
用户可以满世界跑，那是否允许用户就近接入数据中心就对业务处理流程有很大影响。如果允许就近接入，同时还要保证数据一致性不影响业务，就意味着要么用户数据的Master需要可以动态的改变；要么需要对所有业务逻辑进行仔细梳理，严格区分本数据中心和跨数据中心用户的请求，将请求路由到正确的数据中心处理。
考虑到上述问题会带来很高昂的实现和维护的复杂度，我们限制了每个用户只能接入其归属数据中心进行操作。如果用户发生漫游，其漫游到的数据中心会自动引导用户重新连回归属数据中心。
这样用户访问自己数据的一致性问题就迎刃而解了，因为所有操作被限制在归属数据中心内，其数据是有强一致性保证的。此外，还有额外的好处：用户自己的数据（如：消息和联系人等）不需要在数据中心间同步，这就大大降低了对数据同步的带宽需求。
用户访问其他用户的数据
由于不同数据中心之间业务需要互通，用户会使用到其他数据中心用户创建的数据。例如，参与其他数据中心用户创建的群聊，查看其他数据中心用户的朋友圈等。
仔细分析后可以发现，大部分场景下对数据一致性要求其实并不高。用户稍迟些才见到自己被加入某个其他数据中心用户建的群、稍迟些才见到某个好友的朋友圈动态更新其实并不会带来什么问题。在这些场景下，业务逻辑直接访问本数据中心的数据。
当然，还是有些场景对数据一致性要求很高。比方说给自己设置微信号，而微信号是需要在整个微信帐号体系里保证唯一的。我们提供了全局唯一的微信号申请服务来解决这一问题，所有数据中心通过这个服务申请微信号。这种需要特殊处置的场景极少，不会带来太大问题。

可靠的数据同步
数据中心之间有大量的数据同步，数据是否能够达到最终一致，取决于数据同步是否可靠。为保证数据同步的可靠性，提升同步的可用性，我们又开发一个基于Quorum算法的队列组件，这个组件的每一组由3机存储服务组成。与一般队列的不同之处在于，这个组件对队列写入操作进行了大幅简化，3机存储服务不需要相互通讯，每个机器上的数据都是顺序写，执行写操作时在3机能写入成功2份即为写入成功；若失败，则换另外一组再试。因此这个队列可以达到极高的可用性和写入性能。每个数据中心将需要同步的数据写入本数据中心的同步队列后，由其他数据中心的数据重放服务将数据拉走并进行重放，达到数据同步的目的。

负载均衡常用算法：
轮询算法       Round Robin
哈希算法       HASH
最少连接算法    Least Connection
响应速度算法    Response Time
加权法         Weighted

技术的广度是为了在各种条件下都能创造价值，技术的深度是为了在某种条件下能创造最大价值。

多线程，并发，锁机制，集合内部实现及原理，OOM，CPU性能分析，JVM调优，内存模型，类加载，spring，事务管理，MySQL索引原理，SQL优化，执行计划，算法(链表翻转，正方形斜线打印，数组求两数合值)
计算机组成原理，操作系统是应该毕业就掌握的知识。决定级别的不是基础知识，而是你的综合素质，包括表达能力，发现问题的能力，解决问题的能力，你的系统性思考方式。当然项目经验也极为重要，用了哪些工具，踩了哪些坑，能不能发现现有系统的瓶颈和缺陷，这些才能决定你的能力。当然可能面试你的同学级别也不高，能力模型的认知也比较欠缺，那他就很难给你正确的评价了。



1、月薪多少，发放多少个月？年终奖励多少，怎么计算？
2、月薪中是否隐含要达成月kpi才能获得的部分？
3、岗位相关的kpi存在哪些奖惩？
4、公司办公时间？加班的交通报销是否提供？
5、办公设备是否可以自选笔记本还是台式机？如果员工自带设备，公司是否有补贴？（研发人员这个一定要关注）
6、工作日加班、周末加班、节假日加班这些怎么处理？
7、公司是否为员工提供年假、病假，具体是多少？是否带薪？
8、试用期期限，试用期工资占比？月薪发放时间是？
9、缴纳社保、公积金的基数和比例？是否从入职当月就开始缴纳五险一金
10、工资额外的餐补、全勤、车费补贴、团建费等其他补贴分别是多少？是否一定能获得？
11、每年调薪需要满足哪些条件？上调幅度范围多少？
12、内部培训、年度评级、骨干学习、内部晋升这些机制是否提供？


当数据量越来越大，RDBMS数据库撑不住了，就出现了读写分离策略，通过一个Master专门负责写操作，多个Slave负责读操作，服务器成本倍增。随着压力增加，Master撑不住了，这时就要分库了，把关联不大的数据分开部署，一些join查询不能用了，需要借助中间层。随着数据量的进一步增加，一个表的记录越来越大，查询就变得很慢，于是又得搞分表，比如按ID取模分成多个表以减少单个表的记录数。经历过这些事的人都知道过程是多么的折腾。采用HBase就简单了，只需要加机器即可，HBase会自动水平切分扩展，跟Hadoop的无缝集成保障了其数据可靠性（HDFS）和海量数据分析的高性能（MapReduce）。


算法：
二分搜索       Binary Search
分治           Divide Conquer
宽度优先搜索    Breadth First Search
深度优先搜索    Depth First Search
回溯法         Backtracking
双指针         Two Pointers
动态规划       Dynamic Programming
扫描线         Scan-line algorithm
快排           Quick Sort

数据结构部分：
栈             Stack
队列            Queue
链表            Linked List
数组            Array
哈希表          Hash Table
二叉树          Binary Tree
堆              Heap
并查集           Union Find
字典树           Trie




分布式事务典型处理方式
http://kaimingwan.com/post/fen-bu-shi/fen-bu-shi-shi-wu-de-dian-xing-chu-li-fang-shi-2pc-tcc-yi-bu-que-bao-he-zui-da-nu-li-xing

AliSQL性能优化与功能突破的演进之路
https://m.aliyun.com/yunqi/articles/57900

说明书
https://github.com/agentzh/code2ebook

红黑树
1、每个节点不是红色就是黑色
2、根节点为黑色
3、如果节点为红色，其子节点必须为黑色
4、任意一个节点到NULL(树尾端)的任何路径，所含的黑色节点必须相同
红黑树一个很重要的特性是每次更新操作的旋转次数为O(1)；

跳跃表
determistic skiplist

nginx红黑树：
typedef struct ngx_rbtree_node_s ngx_rbtree_node_t;
struct ngx_rbtree_node_s {
  ngx_rbtree_key_t  key;     //节点的key,用于二分查找
  ngx_rbtree_node_t *left;   //左子节点
  ngx_rbtree_node_t *right;  //右子节点 
  ngx_rbtree_node_t *parent; //父节点
  u_char            color;   //颜色
  u_char            data;    //节点数据，只有一个字节，通常无意义
};




